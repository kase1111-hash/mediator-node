import * as fs from 'fs';
import * as path from 'path';
import { VulnerabilityScanner, VulnerabilityFinding, ScanResult } from '../../../src/security/VulnerabilityScanner';

// Mock logger
jest.mock('../../../src/utils/logger', () => ({
  logger: {
    info: jest.fn(),
    warn: jest.fn(),
    error: jest.fn(),
    debug: jest.fn(),
  },
}));

describe('VulnerabilityScanner', () => {
  let scanner: VulnerabilityScanner;
  let tempDir: string;

  beforeEach(() => {
    scanner = new VulnerabilityScanner();
    tempDir = path.join(__dirname, 'temp-scan-test');

    // Create temp directory
    if (!fs.existsSync(tempDir)) {
      fs.mkdirSync(tempDir, { recursive: true });
    }
  });

  afterEach(() => {
    // Clean up temp directory
    if (fs.existsSync(tempDir)) {
      fs.rmSync(tempDir, { recursive: true, force: true });
    }
  });

  describe('initialization', () => {
    it('should initialize with default patterns', () => {
      const patterns = scanner.getPatterns();
      expect(patterns.length).toBeGreaterThan(0);
    });

    it('should have patterns for major vulnerability categories', () => {
      const patterns = scanner.getPatterns();
      const categories = new Set(patterns.map((p) => p.category));

      expect(categories.has('Command Injection')).toBe(true);
      expect(categories.has('Path Traversal')).toBe(true);
      expect(categories.has('Sensitive Data')).toBe(true);
      expect(categories.has('Weak Cryptography')).toBe(true);
      expect(categories.has('Prototype Pollution')).toBe(true);
    });

    it('should allow adding custom patterns', () => {
      const initialCount = scanner.getPatterns().length;

      scanner.addPattern({
        id: 'CUSTOM-001',
        category: 'Custom',
        severity: 'high',
        title: 'Custom Pattern',
        pattern: /customVulnerability/g,
        description: 'Custom vulnerability detection',
        recommendation: 'Fix the custom vulnerability',
      });

      expect(scanner.getPatterns().length).toBe(initialCount + 1);
    });
  });

  describe('scanFile', () => {
    it('should detect eval() usage', async () => {
      const testFile = path.join(tempDir, 'eval-test.ts');
      fs.writeFileSync(testFile, 'const result = eval(userInput);');

      const findings = await scanner.scanFile(testFile);

      expect(findings.some((f) => f.category === 'Command Injection')).toBe(true);
      expect(findings.some((f) => f.title.includes('eval()'))).toBe(true);
    });

    it('should detect new Function() usage', async () => {
      const testFile = path.join(tempDir, 'function-test.ts');
      fs.writeFileSync(testFile, 'const fn = new Function("return 1");');

      const findings = await scanner.scanFile(testFile);

      expect(findings.some((f) => f.title.includes('new Function()'))).toBe(true);
    });

    it('should detect hardcoded credentials', async () => {
      const testFile = path.join(tempDir, 'creds-test.ts');
      fs.writeFileSync(testFile, 'const password = "secretPassword123";');

      const findings = await scanner.scanFile(testFile);

      expect(findings.some((f) => f.category === 'Sensitive Data')).toBe(true);
    });

    it('should detect weak cryptography (MD5)', async () => {
      const testFile = path.join(tempDir, 'crypto-test.ts');
      fs.writeFileSync(testFile, 'const hash = crypto.createHash("md5").update(data).digest("hex");');

      const findings = await scanner.scanFile(testFile);

      expect(findings.some((f) => f.category === 'Weak Cryptography')).toBe(true);
      expect(findings.some((f) => f.title.includes('MD5'))).toBe(true);
    });

    it('should detect weak cryptography (SHA1)', async () => {
      const testFile = path.join(tempDir, 'sha1-test.ts');
      fs.writeFileSync(testFile, 'const hash = crypto.createHash("sha1").update(data).digest("hex");');

      const findings = await scanner.scanFile(testFile);

      expect(findings.some((f) => f.title.includes('SHA1'))).toBe(true);
    });

    it('should detect prototype pollution via __proto__', async () => {
      const testFile = path.join(tempDir, 'proto-test.ts');
      fs.writeFileSync(testFile, 'obj.__proto__.polluted = true;');

      const findings = await scanner.scanFile(testFile);

      expect(findings.some((f) => f.category === 'Prototype Pollution')).toBe(true);
    });

    it('should detect innerHTML usage', async () => {
      const testFile = path.join(tempDir, 'xss-test.ts');
      fs.writeFileSync(testFile, 'element.innerHTML = userInput;');

      const findings = await scanner.scanFile(testFile);

      expect(findings.some((f) => f.category === 'Cross-Site Scripting')).toBe(true);
    });

    it('should detect insecure random number generation', async () => {
      const testFile = path.join(tempDir, 'random-test.ts');
      fs.writeFileSync(testFile, 'const token = Math.random().toString(36);');

      const findings = await scanner.scanFile(testFile);

      expect(findings.some((f) => f.category === 'Insecure Randomness')).toBe(true);
    });

    it('should not flag clean code', async () => {
      const testFile = path.join(tempDir, 'clean-test.ts');
      fs.writeFileSync(
        testFile,
        `
        import { z } from 'zod';

        const schema = z.object({
          name: z.string(),
          age: z.number(),
        });

        function processData(input: unknown) {
          const validated = schema.parse(input);
          return validated;
        }
        `
      );

      const findings = await scanner.scanFile(testFile);

      // Should not have critical or high findings for clean code
      const criticalHigh = findings.filter((f) => f.severity === 'critical' || f.severity === 'high');
      expect(criticalHigh.length).toBe(0);
    });

    it('should include line numbers in findings', async () => {
      const testFile = path.join(tempDir, 'line-test.ts');
      fs.writeFileSync(
        testFile,
        `const x = 1;
const y = 2;
const result = eval(input);`
      );

      const findings = await scanner.scanFile(testFile);

      const evalFinding = findings.find((f) => f.title.includes('eval()'));
      expect(evalFinding).toBeDefined();
      expect(evalFinding?.line).toBe(3);
    });

    it('should include code snippet in findings', async () => {
      const testFile = path.join(tempDir, 'code-test.ts');
      fs.writeFileSync(testFile, 'const badPassword = "secret123";');

      const findings = await scanner.scanFile(testFile);

      const finding = findings.find((f) => f.category === 'Sensitive Data');
      expect(finding?.code).toBeDefined();
      expect(finding?.code).toContain('badPassword');
    });

    it('should handle non-existent files gracefully', async () => {
      const findings = await scanner.scanFile('/nonexistent/file.ts');
      expect(findings).toEqual([]);
    });
  });

  describe('scanDirectory', () => {
    it('should scan all TypeScript files in directory', async () => {
      // Create test files
      fs.writeFileSync(path.join(tempDir, 'file1.ts'), 'const x = 1;');
      fs.writeFileSync(path.join(tempDir, 'file2.ts'), 'const y = 2;');

      const result = await scanner.scanDirectory(tempDir);

      expect(result.filesScanned).toBe(2);
    });

    it('should exclude test files', async () => {
      fs.writeFileSync(path.join(tempDir, 'code.ts'), 'const x = 1;');
      fs.writeFileSync(path.join(tempDir, 'code.test.ts'), 'test("x", () => {});');
      fs.writeFileSync(path.join(tempDir, 'code.spec.ts'), 'describe("x", () => {});');

      const result = await scanner.scanDirectory(tempDir);

      expect(result.filesScanned).toBe(1);
    });

    it('should exclude node_modules', async () => {
      const nmDir = path.join(tempDir, 'node_modules');
      fs.mkdirSync(nmDir, { recursive: true });
      fs.writeFileSync(path.join(nmDir, 'package.ts'), 'const x = eval("bad");');
      fs.writeFileSync(path.join(tempDir, 'app.ts'), 'const y = 1;');

      const result = await scanner.scanDirectory(tempDir);

      expect(result.filesScanned).toBe(1);
    });

    it('should return scan result with summary', async () => {
      fs.writeFileSync(path.join(tempDir, 'vulnerable.ts'), 'const x = eval(y);');

      const result = await scanner.scanDirectory(tempDir);

      expect(result.scanId).toBeDefined();
      expect(result.timestamp).toBeDefined();
      expect(result.duration).toBeGreaterThanOrEqual(0);
      expect(result.summary).toBeDefined();
      expect(result.summary.total).toBeGreaterThan(0);
      expect(result.passed).toBe(false);
    });

    it('should pass when no critical or high findings', async () => {
      fs.writeFileSync(path.join(tempDir, 'clean.ts'), 'const x = 1;');

      const result = await scanner.scanDirectory(tempDir);

      expect(result.passed).toBe(true);
    });

    it('should fail when critical findings exist', async () => {
      fs.writeFileSync(path.join(tempDir, 'critical.ts'), 'eval(userInput);');

      const result = await scanner.scanDirectory(tempDir);

      expect(result.passed).toBe(false);
      expect(result.summary.critical).toBeGreaterThan(0);
    });

    it('should categorize findings by severity', async () => {
      fs.writeFileSync(
        path.join(tempDir, 'mixed.ts'),
        `
        eval(input);
        const pw = "password123";
        Math.random();
      `
      );

      const result = await scanner.scanDirectory(tempDir);

      expect(result.summary.critical).toBeGreaterThanOrEqual(1);
      expect(result.summary.medium).toBeGreaterThanOrEqual(0);
    });

    it('should handle empty directory', async () => {
      const emptyDir = path.join(tempDir, 'empty');
      fs.mkdirSync(emptyDir);

      const result = await scanner.scanDirectory(emptyDir);

      expect(result.filesScanned).toBe(0);
      expect(result.summary.total).toBe(0);
      expect(result.passed).toBe(true);
    });

    it('should handle non-existent directory', async () => {
      const result = await scanner.scanDirectory('/nonexistent/directory');

      expect(result.filesScanned).toBe(0);
      expect(result.passed).toBe(true);
    });
  });

  describe('finding structure', () => {
    it('should include CWE IDs when available', async () => {
      const testFile = path.join(tempDir, 'cwe-test.ts');
      fs.writeFileSync(testFile, 'eval(x);');

      const findings = await scanner.scanFile(testFile);
      const finding = findings[0];

      expect(finding.cweId).toBeDefined();
      expect(finding.cweId).toMatch(/^CWE-\d+$/);
    });

    it('should include OWASP categories when available', async () => {
      const testFile = path.join(tempDir, 'owasp-test.ts');
      fs.writeFileSync(testFile, 'eval(x);');

      const findings = await scanner.scanFile(testFile);
      const finding = findings[0];

      expect(finding.owaspCategory).toBeDefined();
    });

    it('should include recommendations', async () => {
      const testFile = path.join(tempDir, 'rec-test.ts');
      fs.writeFileSync(testFile, 'eval(x);');

      const findings = await scanner.scanFile(testFile);
      const finding = findings[0];

      expect(finding.recommendation).toBeDefined();
      expect(finding.recommendation.length).toBeGreaterThan(0);
    });
  });
});
